# Week 9 Note

本周开始讲述浏览器原理，从工作流程上看，浏览器的工作可以分为以下几步：

```shell
+---+
|URL|
+---+
  |
  +---+ HTTP
  v
+----+
|HTML|
+----+
  |
  +---+ Parse
  v
+---+
|DOM|
+---+
  |
  +---+ CSS Computing
  v
+------------+
|DOM with CSS|
+------------+
  |
  +---+ Layout
  v
+-----------------+
|DOM with Position|
+-----------------+
  |
  +---+ Render
  v
+------+
|Bitmap|
+------+

```

那么本周的内容主要涵盖了从一个页面请求的发起，直到 `DOM with CSS` 这个阶段的内容，下面就按照课程内容的阶段进行划分。

## 从 Url 到 Html

这一个部分分为服务端和客户端两个部分，由于我们实现的 `Toy Browser` 主要着眼点在客户端，所以服务端我们就没有做过多的复杂处理，而是直接使用 `http` 这个 NodeJS 内置库实现了一个简单的返回 html 页面的服务。

在客户端方面，我们使用了 `net` 库与服务端建立连接，而处理返回体的部分我们手动完成。HTTP 返回主要分为 3 个部分：statusLine、Headers、Body。而 Headers 部分的 `Transfer-Encoding` 属性又能够决定 Body 的编码方式，在这个例子中我们只处理了 `chunked` 类型，其他类型暂未处理。

我们主要使用了状态机来处理拆分 HTML 的返回，其中 StatusLine 相对好处理，因为它总是在返回的头部第一行，并且以 `/r/n` 结尾。而 `Header` 部分就相对难拆分一些，因为我们需要将字符串转换为 `[key]:[value]` 的形式，所以我们以换行符做分割，分别获取冒号前和冒号后的内容进行对象的拼接来获取 Headers 对象。最后获取整个的 Body 部分（这里直接就是 html 字符串）来交给 `Parse` 阶段处理。

## 从 Html 字符串到 DOM AST

这里我们参考了 [WhatWG 标准中的 parsing-tokenization 部分](https://html.spec.whatwg.org/multipage/parsing.html#tokenization) 对 Html 字符串部分进行解析，并且根据我们的简单测试用例简化了状态机模型，只实现了部分结构。最后我们利用了二十多个状态的状态机生成了一棵完整的 DOM 树，但是这时的 `<style>` 标签还仅仅是作为一个普通的 DOM 节点来处理，并没有针对其中的每条规则与我们生成的 DOM 树之间产生关联，这也是下一步需要做的。

## 从 DOM 到 DOM with CSS

在这个步骤中，我们使用了 `css` 这个 npm 包对我们的 `<style>` 标签中的样式规则进行解析，将其中的样式规则按照 `selector` 进行分类，并且我们也修改了 `Html` 的 Parsing 过程，使得我们的 DOM 树能够在生成完成时为每个节点带上样式的配置信息，而不是在生成完 `DOM` 树以后再重新扫描生成一遍。在生成节点的时候我们发现，如果说一个节点具备多级选择器的话，我们需要 `自内向外`（站在 CSS 选择器的角度是 `从右至左`）的将选择器与节点及其父节点进行匹配，完整匹配后的结果记录进当前节点，作为当前节点的样式属性。

但这样又产生了新的问题，就是有可能有多个选择器能够对同一个节点匹配成功，如果不设置优先级的话那么后来的样式属性会完全覆盖先前的属性。那么此时我们引入了 CSS 的 Specificity 概念，它主要由四个部分组成 `inline` `id` `className` `tagName`，优先级依次递减，当高位优先级能够比较出结果则忽略低位优先级的计算。根据这个规则，我们就可以确定最终 DOM 节点的样式以及它的样式来源和覆盖关系，这也就能解释为什么浏览器 DevTools 中能够展示 CSS 优先级的覆盖关系。

## 总结

在本周课程和练习完成过程中，加深了对浏览器中对 Html 的解析以及 CSS 与 DOM 树关系的创建，更深入的理解了为何浏览器对 CSS 规则选择器的解析是从右至左的顺序。并且在完成练习的过程中也了解到了一些特殊的边界情况下 CSS 规则优先级有关方面的知识。虽然在扩展练习中我只实现了简单的代码扩展（如：支持带空格分隔的 className 定义，以及复合选择器的权重计算），虽然没有办法覆盖所有的标准定义的情况，但是帮助我拓展了我在浏览器解析方面的知识边界。

### 几个比较值得记录的点

1 id & class 选择器是可以通过重复定义来提高选择器的 specificity 的。[MDN: How is specificity calculated](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#How_is_specificity_calculated)

2 复合选择器 `#id.c1` 与 `.c1#id` 优先级相同，定义顺序靠后的规则覆盖靠前的规则。（并不只能简单的以开头第一个符号判断一组选择器的权重） 
