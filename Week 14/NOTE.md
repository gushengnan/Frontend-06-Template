# Week 14 Note

本周主要介绍了 `JSX` 语法及其 `javascript` 的转换过程。之后利用这个编写好的简易版 `React` 实现了一个 `Carousel` 组件，支持自动播放和手动拖动两种模式，类似 [`Swipper`](https://swiperjs.com/) 组件中能够实现的功能。

## JSX

`JSX` 是一种由 `React` 官方提出的 `JavaScript` 的语法扩展，起初是针对 `React` 框架设计的一种 `html` 与 `javascript` 之间作为粘合剂的语法扩展，它能够使用类似于 `html` 标签嵌套关系来代替 `createElement` 递归调用，增加渲染部分代码的可读性，并且可以在语法中嵌入 `javascript` 表达式，让这种语法能够灵活的满足各种条件渲染和循环渲染的情况。后来 `Vue` 也在模板语法之外提供了支持 `jsx` 语法的能力，使得它不仅仅只跟 `React` 框架做绑定，也广泛的应用于开源社区的很多 UI 框架中。

当然，用这种语法来表达 `html` 的渲染也不是没有缺点的，更高灵活性 + `javascript` 能力支持也使得 `jsx` 的静态编译优化非常的难，因为任意模板语言都有其限制，那么这些限制带来的好处就是在编译时能够做尽可能多的优化来降低 `动态节点` 的数量，而 `jsx` 对中 `js` 的支持导致很多编译时的静态分析是没有办法做到极致的，因为 `javascript` 本身的动态语言特性导致很多变量或者表达式只有在运行时才能够拿到其真正的值，而在编译时 `javascript` 表达式是没有办法做更进一步的 `推断` 的，也许使用 `typescript` 的 `tsx` 能够将静态编译时的优化做的更好，但是跟模板语言本身相比还是有差距的。这也是 React Team 在设计 jsx 和 React 时所做的一种 trade off。

### 转换

JSX 这种语法通过编译后会转换成 `createElement` 递归调用的这种方式，最终生成一颗虚拟的 `DOM Tree`，再经由 `react-dom` 或 `react-xxx` 针对不同平台的渲染方法将其转换为一颗能够在不同平台上进行展示的 `真实的 Tree` 的结构。而能够让我们做到这一点的就是 `@babel/plugin-transform-react-jsx` 这个转换器，它默认会使用 `React.createElement` 这个方法来生成虚拟 DOM，当然我们也可以替换为任意的自己实现的函数。

## 组件化

其实本周的组件化示例还不能算是一个真正的实用的组件，虽然轮播的逻辑已经封装在了组件中，但是一旦涉及了组件生命周期中的卸载，那么我们没有经过任何的处理。并且轮播组件的大小位置等都是在组件内部控制的，这些应该是在组件设计的时候放在外部以参数的方式传递。

## 总结

可能 winter 老师是不想在课程中将我们的组件化与框架相结合，所以实现了一个与框架无关的组件的示例。对于 `jsx` 这块的知识也起到了很好的原理说明作用。