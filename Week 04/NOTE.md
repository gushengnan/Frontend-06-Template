# Week 4 Note

本周对一些字符串解析的算法进行了介绍，结合本周课程内容中涵盖的算法，已经处理了包含以下除 `状态机` 外的其他所有算法。

## 字符串分析算法概览
- Trie（字典树）  
    大量高重复字符串的存储与分析
- KMP  
    在长字符串里找模式
- Wildcard  
    带通配符的字符串模式
- 正则  
    字符串通用模式匹配
- 状态机  
    通用的字符串分析
- LL LR  
    字符串多层级结构分析

## Trie

将多个字符串以字符索引为深度构建的树型结构，能够节省很多的存储空间，因为同一个索引的字符只需要存储一次。可以用 `DFS` 的方法来做字符串的查询，查询复杂度跟字符串的长度和字典树每一层的节点数量有关。类似如下的结构:

```shell
      - eof
    /
g - o - o - d - eof
\
  - r - e - a - t - eof
```

## KMP

算法的中心思想是尽可能的在模式匹配串中寻找 `重复规律`，进而使用这个规律来将 `Brute Force` 这种复杂度为 O(mn) 的算法复杂度降低至 O(m+n)。

这种 `重复规律` 使用 `KMP` 中的数据结构表达为 `PMT` (Partial Match Table) 。

### PMT

在某个索引位置字符串的前缀和后缀（前后缀不包含完整字符串的情况）交集中最长字符串的长度，记为 pmt 表中该位置的值，举例如下：

1. eg: `ababaab`

`PMT` 推演过程

| index          | 0 | 1  | 2    | 3        | 4             | 5                   | 6                          |
|----------------|---|----|------|----------|---------------|---------------------|----------------------------|
| str            | a | ab | aba  | abab     | ababa         | ababaa              | ababaab                    |
| 前缀           |   | a  | a,ab | a,ab,aba | a,ab,aba,abab | a,ab,aba,abab,ababa | a,ab,aba,abab,ababa,ababaa |
| 后缀           |   | b  | ba,a | b,ab,bab | a,ba,aba,baba | a,aa,baa,abaa,babaa | b,ab,aab,baab,abaab,babaab |
| 最长公共前后缀 |   |    | a    | ab       | aba           | a                   | ab                         |
| pmt            | 0 | 0  | 1    | 2        | 3             | 1                   | 2                          |

`PMT` 结果

| char  | a  | b | a | b | a | a | b |
|-------|----|---|---|---|---|---|---|
| index | 0  | 1 | 2 | 3 | 4 | 5 | 6 |
| pmt   | 0  | 0 | 1 | 2 | 3 | 1 | 2 |
| next  | -1 | 0 | 0 | 1 | 2 | 3 | 1 |

- - -

2. eg: `abababca`

`PMT` 推演过程

| index          | 0 | 1  | 2    | 3        | 4             | 5                   | 6                          | 7                                  |
|----------------|---|----|------|----------|---------------|---------------------|----------------------------|------------------------------------|
| str            | a | ab | aba  | abab     | ababa         | ababab              | abababc                    | abababca                           |
| 前缀           |   | a  | a,ab | a,ab,aba | a,ab,aba,abab | a,ab,aba,abab,ababa | a,ab,aba,abab,ababa,ababab | a,ab,aba,abab,ababa,ababab,abababc |
| 后缀           |   | b  | a,ba | b,ab,bab | a,ba,aba,baba | b,ab,bab,abab,babab | c,ba,abc,babc,ababc,bababc | a,ca,bca,abca,babca,ababca,bababca |
| 最长公共前后缀 |   |    | a    | ab       | aba           | abab                |                            | a                                  |
| pmt            | 0 | 0  | 1    | 2        | 3             | 4                   | 0                          | 1                                  |

`PMT` 结果

| char  | a  | b | a | b | a | b | c | a |
|-------|----|---|---|---|---|---|---|---|
| index | 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| pmt   | 0  | 0 | 1 | 2 | 3 | 4 | 0 | 1 |
| next  | -1 | 0 | 0 | 1 | 2 | 3 | 4 | 0 |


### next 的意义

> 主串记为 `S`，模式串记为 `P`。

如果只有 `PMT` 表是不够的，因为在进行匹配的过程中我们需要的并不是每个位置对应 `P` 子串的公共前后缀最大长度，而是需要有效的利用这个规律来降低我们的复杂度，`next` 的意义就在于此。

`next` 中值的意义，每一位对应的值代表了当主串在进行一轮 `Brute Force` 算法匹配失败后，在 `S` 进入下一轮匹配时，模式串可以跳过的最大字符长度，也就是 `P` 串匹配的起始点。

- 为什么

假设 `S = abcabcabd` & `P = abcabd`，第一轮从 `S[0] P[0]` -> `S[5] P[5]` 的时候失败，如果按照 `Brute Force` 的方法进入下一轮，则会从 `S[1] P[1]` -> `S[6] P[6]`，但其实这是没必要的，因为我们已经知道 `S` 串的前六位并且知道了在匹配到 `S[5] P[5]` 的时候会失败，那么根据先前匹配的 `经验`(`S[0]-S[4] === P[0]-P[4]`) 和对模式串 `P` 的内部规律分析可知，我们可以直接跳过 `S[1] S[2]` 这 `2` 轮(从 `next` 中对应的 `P` 串索引中获取)，直接从 `S[3]` 开始匹配模式串的 `P[0]`。

| S      | a | b | c | a | b | c | a | b | d |
|--------|---|---|---|---|---|---|---|---|---|
| start  | a✔️ | b✔️ | c✔️ | a✔️ | b✔️ | d❌|   |   |   |
| ignore |   | a | b | c | a | b | d |   |   |
| ignore |   |   | a | b | c | a | b | d |   |
| end    |   |   |   | a✔️ | b✔️ | c✔️ | a✔️ | b✔️ | d✔️ |

- 引申
    * P = `abcde`  
        `next = [-1, 0, 0, 0, 0]`，每次匹配失败都会从 `P` 串的头和 `S` 串的下一个位置开始匹配。
    * P = `aaaaa`
        `next = [-1, 0, 1, 2, 3]`，对于连续 `a` 字符的 `S` 串效率提升明显。
    * P = `ababa`
        `next = [-1, 0, 0, 1, 2]`, 对于有连续 `ab` 字符的 `S` 串效率提升明显。

    > 如果只根据 `P` 串的规律来看 `KMP` 的提升其实是不够的，还需要看匹配字符串中是否包含与 `P` 串类似的模式，规律越相似，执行效率越高，反之则越低。


### KMP 的 JavaScript 实现

从实现上看，可以分为 `next` table 的生成与匹配两个部分，但是其实总结看来都是 `KMP`，只不过 `next` 是用 `P` 跟本身去做匹配，而后再用 `P + next` 与 `S` 去做匹配。

- `next` table 实现

```javascript
// 生成空的 next table，默认值为0
let table = new Array(pattern.length).fill(0);
// 第一位赋 -1（也可以不赋值保持0，这里为了做区分），因为第一位没有前后缀，都是从第二位开始
table[0] = -1;
// i 看作 S 串的指针，j 看做 P 串的指针
let i = 1, j = 0;
while (i < pattern.length) {
    // 对位字符相同时
    if (pattern[i] === pattern[j]) {
        ++j, ++i;
        table[i] = j;
    // 对位字符不匹配时
    } else {
        /**
         * 如果 S 串有可推进长度，则在下一循环中: 
         * - S 串相较 Brute Force 跳过 j 次主循环
         * - P 串跳过了（j - table[j]）个长度，也就是跳过了相较于 Brute Force 中的（j - table[j]）次子循环
         */
        if (j > 0) {
            j = table[j];   
        } else {
            /**
             * 如果 S 串无可推进长度，则在下一循环执行 === Brute Force 主循环索引 + 1
             */    
            ++i;
        }
    }
}
```

- 匹配实现

```javascript
// ...

/**
 * 与 next 算法类似
 * 1 只是 P 与 S 的起始匹配位置均从 0 开始
 * 2 设定退出条件为 P 串一直匹配到结束都没有出现不匹配的情况，则返回 true
 */   
let i = 0, j = 0;
while (i < source.length) {
    if (pattern[j] === source[i]) {
        ++j, ++i;
    } else {
        if (j > 0) {
            j = table[j];
        } else {
            ++i;
        }
    }
    if (j === pattern.length) {
        return true;
    }
}
return false;
```

## Wildcard

- 定义

    类似一种简化版的正则表达式，`?` 代表匹配任意一个字符，`*` 代表匹配零个或任意个字符。

- 处理思路

将 `pattern` 按 `*` 拆分成多个子串，拼接成正则表达式进行匹配，非最后一位的 `*` 在正则中做非贪婪匹配，最后一个星号做贪婪匹配，但是从后向前（避免最后一位是星号的情况）。

1. 情况一：`pattern` 中没有 `*`

    使用 `BF` 算法逐位匹配，遇到问号直接进入下一个索引位置，直达到 `pattern` 串长度结束。
        
2. 情况二：`pattern` 中只有一个 `*`

    使用 `BF` 从 `pattern` 尾部向前 `BF` 匹配，如果最后一个 `*` 后没有字符，则直接匹配成功，如果 `*` 后有字符，只要确保 `*` 后的字符匹配成功到 `*` 索引位置成功即可返回 `true`。

3. 情况三：`pattern` 中有两个或者两个以上 `*`

    除最后一个 `*` 以外，用拼接正则表达式的方式解决，也就是用 `[\\s\\S]` 来替换 `?`，并从上一个 `*` 索引开始匹配，如果匹配成功，则将正则匹配的 `lastIndex` 记下，作为下一轮的匹配起点。

    最后一个 `*` 使用 `情况二` 的解决方式。

## 结语

循环、递归、深度优先搜索、广度优先搜索等都是复杂算法的基石，无论是刷题也好，还是说一些在实际开发中遇到的场景也好，其实都大量应用到了这些基础的算法。夯实算法基础在前端精进的必经之路。

而更高级的复杂算法则是为了解决某一特定领域问题而生，在一些类库或者框架中高频调用的代码中使用能够很大程度上提升性能。